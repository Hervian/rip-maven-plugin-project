TL;DR status: 
* Make WrapClientsTask work. Make it into a Mojo, see comment in top.
* Auto-generate the REST class which for now is hardcodet in the JokesAndFactsServer project.
* Auto-generate the Aspect class which for now is hardcodet in the JokesAndFactsServer project.
* The generate client task should somehow make IntelliJ ignore the autogenerated client. Currently one needs to "unmark sources root" on the generated test folder...

Status: 
 1. Have added creation of Dart client, and am trying to figure out what 'install' and 'deploy' means
for Dart as compared to java. Compile to what, and install where? 
Artifactory can store dart files. Perhaps focus on that: https://www.jfrog.com/confluence/display/JFROG/Pub+Repositories
More general info on dart repos, including artifactory's: https://medium.com/dartlang/hosting-a-private-dart-package-repository-774c3c51dff9
 2. Generate REST class that shows all the API clients.
    1. Runtime scan classpath for relevant types and generate Rest class with methods a la Rest.jokesApi().getRandomJoke();
    2. Feign:
       1. ApiClient apiClient = new ApiClient(); apiClient.setBasePath(jokesServerUrl); JokesApi jokesApi = apiClient.buildClient(JokesApi.class);
       2. Rule:
          1. find public class called ApiClient
          2. find interface *Api (that extends ApiClient.Api)
    3. Native:
    4. Webclient:
       1. new FactsApi(new ApiClient(ApiClient.buildWebClientBuilder().build))
       2. (class) FactsApi factsApi = new FactsApi()
       3. WebClient.Builder builder = ApiClient.buildWebClientBuilder(); FactsApi factsApi = new FactsApi(builder.build());
       4. Like above, but using injection instead of "new Apiclient()".
       5. Rule: 
          1. find public class called ApiClient
          2. find public class that ends with "Api" and has 1 or more constructors accepting a public class called ApiClass
          3. At least 1 of the ApiClient's constructors accepts a org.springframework.web.reactive.function.client.WebClient
          4. Has at least 1 public buildWebClient method 
    5. General rule:
       1. find public class called ApiClient
       2. Determine REST framework by inspecting imports: 
          1. Feign: "import feign.Feign;"
          2. WebClient: "import org.springframework.web.reactive.function.client.WebClient;"
          3. Native: "import java.net.http.HttpClient;"
       3. find type (class or interface) that 
          1. A) ends with *Api and 
             1. is an interface AND the return product of a builder method on aforementioned ApiClient (Feign) 
             2. OR is a class with a constructor accepting aforementioned ApiClient (WebClient)
       4. 1 and 3 must be in the same package? Or at least in the same jar.
       5. Consider limiting the search to jars that contain a pom that contain the string "OpenAPI-Generator" (case-insensitive)
 3. Refactor package structure and replace mojos RestInPeaceMojo - work in progress/partially completed? TODO: I think the wrapClientsTask MUST run before compile - otherwise compile will break on any reference to not-yet-existing classes.

GenerateClientMojo has errors in that the generated client code does not compile since the 
plugin used hsa problems with the Æ Ø Å characters in a enum generation. 
They are turned into underscores. See generated java code and see this class which is reponsible: https://github.com/OpenAPITools/openapi-generator/blob/84660920873893358ad119a1306143a12399db77/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java#L83 line 774
For this reason I am test building chub-services against a modified version of chub-wsdl with ÆØÅ removed.
TODO: make generated client methods include HystrixCommand annotations for curcuit breaking. https://www.baeldung.com/spring-cloud-netflix-hystrix

The deployClient code has not been tested, neither for java nor dart.
TODO: Does the mvn command of the generate and deploy client logic work for both ssh and username/password access?
TODO: Does the generate doc work for both standard jax-rs and Spring MVN annotations?

# swagger-maven-plugin
This plugin is intended to be a one-stop-shop for everything swagger (OpenAPI) related. 
No dependencies are needed - you only need to add the plugin and let the code generation it makes use of do its work.

What you can/can configure:
* generation of swagger.json file (mandatory)
* generation of static documentation such as HTML and Confluence wiki markup text. (This is useful if you want your build to deploy the REST documentation to your company's Confluence server)
* Breaking API changes check - will fail the build if there are breaking REST API changes AND the major version of the pom has not been increased.
  * See https://redskap.github.io/swagger-brake/maven/#latest-maven-artifact-resolution
* generation of swagger-ui (optional. Also: the swagger-ui files can be customized)
* generation and deploy of client code (optional. I.e. the plugin can be configured to create and deploy (to say Nexus) a Java client when calling 'mvn clean deploy').

<pre>
	Description: One stop shop for documenting your java REST server: embedded swagger-ui + compile time generation of swagger.json + compile time generation of java client as separate jar.
		Compile time generate swagger doc + optional html
			Why compile time? Because
				a) otherwise tools that need this are dependent on a live server, that may be down.
				b) Some companies secure their build servers by only allowing them to access binary repositories, i.e. they would block a connection to retrieve the swagger.json (which you may need to build, say a javascript client for your server).
		Optionally deploy swagger-ui
		Optionally generate a java client for your server as a separate binary artifact.
			Example, when running 'mvn clean deploy' on your server code, you can configure the plugin to also create a client jar for that server, which will also be deployed to say Nexus.
		Configuration of all of the above and the exact behavior can be controlled via an annotation in your source code, which the plugin will find via annotation scanning.
	Plugin:
		Execution 1: compile phase
			Scan for configuration annotation/class: https://stackoverflow.com/q/18634850
			Generate swagger.json
		Execution 2, process-classes phase?
			if (Configuration.generateClient && semanticVersioningIndicatesNewAPI)
				generate client code from swagger.json
				mvn [inherited mvn options] client code.
</pre>

## Table of Contents  
[Releases](#releases)
[Configuration](#configuration)
[Troubleshooting](#troubleshooting)
[Related projects](#related-projects)  

## Releases
Available in TODO:  

Requires **Java 8** or above.
See requirements section if you need to use this library with *Java 8*.

## Documenting your API
Use annotations from io.swagger.v3.oas.annotations and javax.ws.rs. TODO: Does it work with Spring REST annotations?
Example: Use @io.swagger.v3.oas.annotations.Operation instead of @io.swagger.annotations.ApiOperation.

## Configuration
Example configuration:  
```
    <plugin>
        <groupId>com.github.hervian</groupId>
        <artifactId>swagger-maven-plugin</artifactId>
        <version>1.0-SNAPSHOT</version>
        <configuration>
          <resourcePackages>
            <resourcePackage>dk.tdc.chub.exposure.v1</resourcePackage>
          </resourcePackages>
          <fileCustomizer>dk.tdc.chub.config.SwaggerUiCustomizer</fileCustomizer>
          <additionalDocs>
            <additionalDoc>CWIKI</additionalDoc>
          </additionalDocs>
        </configuration>
        <executions>
          <execution>
            <goals>
              <goal>generateDoc</goal> <!--Mandatory goal. Bound to Compile phase. Optional configuration: 1) Add @io.swagger.v3.oas.annotations.OpenAPIDefinition annotation anywhere in your source code to customize the generated swagger doc. 2) Add other swagger annotations to your REST methods to add detailed documentation (@Api, @ApiOperation etc). Note that both requires that you add the relevant dependency to get those annotations on the classpath if not already present. -->
              <goal>generateUi</goal> <!--Optional goal. Bound to Compile phase. -->
              <goal>generateClient</goal> <!--Optional goal. Bound to Deploy phase. TODO: Optionally add ...-->
            </goals>
          </execution>
        </executions>
      </plugin>
```

## Troubleshooting
### swagger-maven-plugin: Generate swagger doc
If the invoked plugin (swagger-maven-plugin) can't find any jax-rs endpoint you will
in the currently used version of that plugin receive a very uninformative NullPointerException which seems to have to
do with the plugin trying to sort non existing endpoints/paths.
Please check your configuration of the plugin: Are you pointing it to a package that actually contains your resource?
```
[...]
<configuration>
  <generateDocConfig>
    <resourcePackages>
      <resourcePackage>com.my.package.with.jaxrsendpoints</resourcePackage>
    </resourcePackages>
```  
SpecValidationException: -attribute info is missing.
The Open Api spec requires a "info" tag, but you have not specified it. 
You can fix this by adding something a la this to your code:  
`@io.swagger.v3.oas.annotations.OpenAPIDefinition(info= @Info(title="My cool REST API", version = "1.0"))`

### Swagger-brake-maven-plugin: Breaking changes check
The swagger-brake project will throw a NullPointerException if the swagger.json document it uses as input is ill-formed.
Other tools may not consider it ill-formed, but the swagger-brake tool seems quite strict.
Possible causes: your REST methods returns void or javax.ws.rs.core.Response for which reason a schema element is missing in the generated doc. 
Solution: Return some type, fx String, or use swagger annotations to inform the codegen tool that generated the doc how to fill
in the schema element: @ApiResponse(description = "asdf", content = @Content(schema = @Schema(implementation = Response.class))).
I am unsure why the codegen plugin does not produce any schema element when the return type is the abstract type Response.

## Related projects
See pom for which projects are used under the hood (since present plugin delegates all 
the heavy lifting to other plugins).
* TODO list swagger-codegen, swagger-maven-plugins


TODO:
Ask swagger-brake maven plugin on github to improve logging when swagger doc lacks schema info which
for my generate doc setup can happen if rest method returns Response or void AND does not
have any swagger ApiResponse annotation with addition info about the return type.
The breaking changes check gives a somewhat difficult to interpret NPE:
Caused by: java.lang.NullPointerException
at io.redskap.swagger.brake.core.model.transformer.ApiResponseTransformer.resolveReferencedSchemas (ApiResponseTransformer.java:
52)
at io.redskap.swagger.brake.core.model.transformer.ApiResponseTransformer.transform (ApiResponseTransformer.java:36)
at java.util.stream.ReferencePipeline$3$1.accept (ReferencePipeline.java:193)
at java.util.stream.ReferencePipeline$3$1.accept (ReferencePipeline.java:193)
at java.util.Iterator.forEachRemaining (Iterator.java:116)
at java.util.Spliterators$IteratorSpliterator.forEachRemaining (Spliterators.java:1801)
at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:482)
at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:472)
at java.util.stream.ReduceOps$ReduceOp.evaluateSequential (ReduceOps.java:708)
at java.util.stream.AbstractPipeline.evaluate (AbstractPipeline.java:234)
at java.util.stream.ReferencePipeline.collect (ReferencePipeline.java:499)
at io.redskap.swagger.brake.core.model.transformer.PathItemTransformer.getResponses (PathItemTransformer.java:99)
at io.redskap.swagger.brake.core.model.transformer.PathItemTransformer.transform (PathItemTransformer.java:57)
at io.redskap.swagger.brake.core.model.transformer.PathTransformer.transform (PathTransformer.java:43)
at io.redskap.swagger.brake.core.model.transformer.PathTransformer.transform (PathTransformer.java:34)
at io.redskap.swagger.brake.core.model.transformer.OpenApiTransformer.transform (OpenApiTransformer.java:33)
at io.redskap.swagger.brake.core.model.transformer.OpenApiTransformer.transform (OpenApiTransformer.java:12)
at io.redskap.swagger.brake.runner.Checker.check (Checker.java:30)
at io.redskap.swagger.brake.runner.Runner.run (Runner.java:52)
at io.redskap.swagger.brake.runner.Starter.start (Starter.java:15)
at io.redskap.swagger.brake.maven.StarterWrapper.start (StarterWrapper.java:11)
at io.redskap.swagger.brake.maven.Executor.execute (Executor.java:22)
at io.redskap.swagger.brake.maven.SwaggerBrakeMojo.execute (SwaggerBrakeMojo.java:79)

