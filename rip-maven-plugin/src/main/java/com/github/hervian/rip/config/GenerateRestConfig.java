package com.github.hervian.rip.config;

import com.google.common.collect.Lists;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.maven.plugins.annotations.Parameter;

import java.io.File;
import java.util.List;

/*import static com.github.hervian.rip.tasks.config.WrapClientsConfig.Aspect.CIRCUIT_BREAKER;
import static com.github.hervian.rip.tasks.config.WrapClientsConfig.Aspect.RETRY;*/

//TODO: make use of this config
@NoArgsConstructor
@Data
public class GenerateRestConfig {

  @Parameter(defaultValue="${project.build.directory}/generated-sources/rest", required=true)
  private String targetFolder;

  /**
   * package of the ...?
   */
  @Parameter(required = false)
  private String location; //TODO: defaults to groupId.artifactId.?

 /* *//**
   * A fully qualified class name of a class extending the auto-generated class RestRequestAspect.Decorator.
   * Note that the default value is the the auto-generated class RestRequestAspect.Decorator.
   * This option gives you a chance to decorate the intercepted, outgoing REST requests.
   * If you don't want any decorator at all, i.e. no curcuitbreaking etc, then you must provide
   * a no-op Decorator.
   * Note that your Decorator must extend from the auto-generated class RestRequestAspect.Decorator
   * (be that directly or indirectly) and that a classcast exception will be thrown if it does not.
   *//*
  @Parameter
  private String decorator;*/

  /**
   * When generating the static methods of the autogenerated Rest class the default behavior of the plugin
   * is to generate a static method on the Rest class that has the simple name of the given Api class.
   * Sometimes it might happen that you have two different Apis on your classpath with the same simple name.
   * In that case you will get a compile error thrown by the plugin.
   * To solve it you must edit your plugin configuration such as to map one of the duplicate Api names to something else
   * than the simple name such as to avoid a name collision.
   */
  @Parameter
  private List<ApiName> apiNames = Lists.newArrayList();

  /*//https://skaveesh.medium.com/how-i-decoupled-resilience4j-circuit-breaker-from-the-code-with-aop-in-spring-boot-for-better-code-6af89038057d
  @Parameter
  private List<Aspect> aspects = Lists.newArrayList(CIRCUIT_BREAKER, RETRY); //TODO, work in progress. When generating the Rest class also generate/copy-paste a set of Aspects for decorating the found Apis with stuff like Curcuitbreakers, Retry etc

  public static enum Aspect { //https://resilience4j.readme.io/docs/getting-started-3
    CIRCUIT_BREAKER,
    RETRY,
    LOGGER,
    METRIC,
    BULKHEAD,
    RATE_LIMITER,
    TIME_LIMITER;
  }*/

  @Data
  public static class ApiName {

    @Parameter
    private String fqcn;

    /**
     * The desired name of the api. That is, whatever you write he will become accessible in the Rest class as a static method.
     * <br>Example: Let's say you want to map my.company.SomeCoolApi to PowerApi, then setting fqcn=my.company.SomeCoolApi and name=PowerApi
     * will create make something a la the following possible: <code>Rest.powerApi().issueSomeCoolRestReqeust();</code>
     *
     * The default behavior is to use the simpler name of the Api class.
     */
    @Parameter
    private String name;
  }

}
